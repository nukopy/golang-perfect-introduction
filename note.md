# メモ：プログラミング言語 Go 完全入門

スライドの写経、Go に関することなどのメモ書き

## chap01：Go に触れる

### Go とは

- Google が開発したプログラミング言語
- 特徴
  - 強力でシンプルな言語設計と文法
  - 並行プログラミング
  - 豊富な標準ライブラリ群
  - 周辺ツールの充実
  - シングルバイナリ・クロスコンパイル（OS、アーキテクチャを指定してコンパイルできる）

### Go が開発された背景

- **Google 内の課題を解決するために開発された**
  - 開発速度の低下
    - 超巨大なコードベース
    - 複雑な依存関係
  - マルチコア時代のシステム言語
    - 並行処理とガベージコレクタを同時に採用
  - 軽量プログラミング言語（LL、Light weight Language）の盛り上がり
    - 静的型付け言語だとコンパイル時にエラーが発見できる
    - 動的型付け言語だと書きやすい
    - 静的 / 動的型付け言語のいいところどりをした書きやすい静的型付け言語が Go
  - 静的解析がしやすい
    - 言語設計レベルで静的解析しやすい言語を目指した

### Go の特徴：概要

- 強力でシンプルな言語設計と文法
- 並行プログラミング
- 豊富な標準ライブラリ群
- 周辺ツールの充実
- シングルバイナリ・クロスコンパイル（OS、アーキテクチャを指定してコンパイルできる）

#### 強力でシンプルな言語設計と文法

- 強力でシンプルな言語設計と文法
  - スクリプト言語の書きやすさ
    - 冗長な記述は必要ない
  - 型のある言語の厳密さ
    - 曖昧な記述できない
  - 考えられたシンプルさ
    - 機能を増やすことで言語を拡張していくことはしない
    - 例えば、他の言語の良さそうな機能を Go にどんどん取り入れていくという文化ではない。できる限り言語設計はシンプルに保つ。

Go に入って Go に従え = 言語の思想を理解するのが大事

#### 並行プログラミング

- ゴールーチン
  - **軽量なスレッド**に近いもの（スレッドとは何が違うの？）
  - `go` キーワードを付けて関数呼び出し

```go
// 関数 f を別のゴールーチンで呼び出す
go f()
```

- チャネル
  - ゴールーチン間のデータのやり取り（スレッド間のデータのやり取りと同じ要領）
  - 安全にデータをやり取りできる

#### 豊富な標準ライブラリ

- 標準ライブラリ一覧
  - https://pkg.go.dev/std

| 標準ライブラリ名  | 内容、機能             |
| ----------------- | ---------------------- |
| fmt               | 書式、出力に関する処理 |
| net/http          | HTTP サーバなど        |
| archive, compress | zip や gzip など       |
| encoding          | JSON、XML、CSV など    |
| html/template     | HTML テンプレート      |
| os, path/filepath | ファイル操作など       |

#### 周辺ツールの充実

- `go tool` として標準 / 準標準で提供
- サードパーティ製のツールも充実
- IDE によらない独立したツールとして提供

| コマンド             | 内容、機能                            |
| -------------------- | ------------------------------------- |
| `go build`           | ビルドを行うコマンド                  |
| `go test`            | `xxxx_test.go`                        |
| `go doc`, `godoc`    | ドキュメント生成                      |
| `gofmt`, `goimports` | コードフォーマッタ                    |
| `go vet`             | コードチェッカー                      |
| `gopls`              | Language Server Protocol（LSP）の実装 |

#### シングルバイナリ・クロスコンパイル

- シングルバイナリになる
  - コンパイルするとデフォルトで単一の実行可能ファイルが生成される（C / C++ などと同じ）
  - 動作環境を特別に用意しなくてもよい（バイナリなので、インタプリタを必要とする言語と異なり、動作させる際に言語処理系が必要ない）
- クロスコンパイルできる
  - 開発環境とは違う OS やアーキテクチャ（CPU）向けのバイナリが作れる
  - 環境変数の `GOOS`（OS を指定）と `GOARCH`（アーキテクチャを指定）を指定する

```sh
# Windows(32 ビット)向けにコンパイル
$ GOOS=windows GOARCH=386 go build

# Linux(64 ビット)向けにコンパイル
$ GOOS=linux GOARCH=amd64 go build
```

`go build` は Go のソースコードをビルドするコマンド

### Go を学ぶ理由

- 多くのプロダクトで採用
  - https://github.com/golang/go/wiki/GoUsers#japan
- チーム開発に向いている
  - 静的型付け
  - 文法がシンプル
- パフォーマンスが良い
  - ゴールーチンとチャネル
  - バイナリになる（インタプリタを必要とする言語と異なり、動作させる際に言語処理系が必要ない）

### コンパイルと実行

- `go build` コマンド
  - コンパイルして実行可能ファイル（バイナリファイル）を生成

```sh
go build main.go
go build .
go build pkg_name
```

- `go run` コマンド
  - コンパイルから実行まで行う

```sh
go run main.go
go run .
go run pkg_name
```

### コーディングに必要なツール

#### コードの書式を揃える

- gofmt
  - 読み方:ごーふむと
  - 標準のフォーマッタ
  - **絶対に使う**
  - `-s` オプションで冗長な書き方をシンプルにできる
- goimports
  - `import` 文を追加 / 削除してくれる
  - 未使用パッケージ `import` コンパイルエラーなのでで必須
  - フォーマットもかける
  - `-s` オプションがない

#### 静的解析ツール

| ツール名      | 機能                                                               |
| ------------- | ------------------------------------------------------------------ |
| go vet        | バグと言えるレベルの誤りを検出（これで検出されるのはだいたいバグ） |
| golint        | （非推奨）Go らしくないコードを検出                                |
| errcheck      | エラー処理のミスを検出                                             |
| staticcheck   | サードパーティ製の静的解析ツール                                   |
| GolangCI-Lint | サードパーティ製の Linter Runner                                   |
| gosec         | セキュリティチェック                                               |

#### PR レビューで静的解析ツールを使用

- reviewdog
  - リポジトリ：https://github.com/reviewdog/reviewdog
  - レビュー時に自動で静的解析ツールを実行する
  - 機械的にチェックできることは機械にやらせる
  - 人間だと忘れたり、心苦しかったりしてチェックが漏れる
  - 設定ファイルを書けば reviewdog が勝手に PR にコメントをくれる

#### デバッグ

- GDB
  - リポジトリ：https://golang.org/doc/gdb
  - 有名な古き良きデバッガ
  - Go 自体にカスタマイズされてるわけではない。（Go 開発では使わない？）
- Delve
  - リポジトリ：https://github.com/derekparker/delve
  - Go 専用のデバッガでよく使われる
  - ゴールーチンやチャネルにも対応
- panic デバッグ
  - `panic` 関数を使ってデバッグ
  - スタックトレースが出るので便利
- print デバッグ

## 小休止

Go を Homebrew を用いてインストールし、VSCode の Go 拡張を入れてコードを書き始めようとしたら、Go 拡張に必要なツールが無くて怒られた。

以下、必要なツールのインストールコマンド。

```sh
# "gopls"（Language Server Protocol）
go get -v golang.org/x/tools/gopls

# "goimports"
go get -v golang.org/x/tools/cmd/goimports

# "go-outline"
go get -v github.com/ramya-rao-a/go-outline

# "gopkgs"
go get -v github.com/uudashr/gopkgs/v2/cmd/gopkgs
```

## 基本構文

1. 変数
2. 定数
3. 演算子
4. 制御構文

### 変数

#### 変数とは

- 変数 variable
  - 識別子、それに関連付けられたメモリアドレス、型から構成されるもので、プログラミング言語の仕様。プログラム実行中に一時的に値を保存（状態を保存）しておくための仕組みとして利用される。例えば、一時的な計算結果の保持などに利用される。
  - メモリ上にある値なので、マシンが止まると消える（揮発性）
  - プログラムの実行が終わると消える
  - 変数の内容を結果として残したい場合、ファイルなど外部記憶装置上で管理される領域や出力装置（プリンタなど）経由で出力する必要がある

#### 変数と型

- 型 type
  - どういう種類の値かを表すもの
  - 整数、浮動小数点数、真偽値、文字列 など
  - 自分で作ることも可能（ユーザ定義型）
  - 変数の型：どういう種類の値が入るのかを表したもの
- 動的型付け言語
  - **プログラム実行時に型を検証する**（型が無いわけではないよ！）
  - 変数に型がなく、なんでも代入できる
- 静的型付け言語
  - **コンパイル時に型を検証する**
  - 変数に型がある、型が違うと代入できない

#### 静的型付けの利点と Go の強い型付け

型の一番の恩恵は、「実装中には見つけづらい、型の不一致によるエラーを実行前にコンパイラにより検出でき、生産性が上がる」ことである。動的型付け言語の場合、型の不一致によるエラーには実装中に気づかず、実行してから実行時エラーとして気付くということがしばしば見られる。

- **実行前に型の不一致を検出できる**
  - コンパイルが通れば型の不一致が起きない
  - 型の不一致によるバグは見つけづらいので、これをプログラム実行前に行えるのは効率的
- **曖昧なものはエラーになる**
  - 暗黙の型変換がない
  - 1 + "2" => "12"（JavaScript）
  - 浮動小数点数と整数の演算など見つけづらいバグが起きにくい
- **型推論がある**
  - 明示的に型を書く必要がない場合が多い

### 定数

- https://blog.golang.org/constants

#### 定数とは

- 定数 constant
  - 値の変わらないもの
  - コンパイル時から値が変わらないもの
  - リテラルで記述されることが多い

#### 定数式

- 定数式
  - 定数のみからなる演算式。コンパイル時に計算される。

例えば以下のようなコード。

```go
100 + 200
1 << 2
"Hello, " + "世界"
!(10 == 20)
```

#### 右辺の省略

- 右辺の省略

```go
func main()  {
    const (
        a = 1 + 2  // 3（以下、全て 3 になる）
        b          // 3
        c          // 3
    )

    fmt.Println(a, b, c)  // 全て 3 が出力される
}
```

#### iota

- iota
  - 連続した定数を作るための仕組み
  - グループ化された名前付き定数の定義で使われる
  - 0 から始まり 1 ずつ加算される値として扱われる

```go
func main()  {
    const (
        a = iota  // + 0
        b         // + 1
    )
    const (
        c = 1 << iota  // 1 << 0 = 1 (0001 --- 0 桁左シフト --> 0001)
        d              // 1 << 1 = 2 (0001 --- 1 桁左シフト --> 0010)
        e              // 1 << 2 = 4 (0001 --- 2 桁左シフト --> 0100)
    )

    fmt.Println(a, b, c, d, e)  // 0, 1, 1, 2, 4
}
```

#### 疑問点

- なぜ「型を持たない定数」という言語仕様を意図して作ったのか？
  - どういうメリットが有るのか？定数にも確実に型付けが行われるような仕様にした方が良いのではないか？

### 演算子

#### Go の演算子

- 演算子一覧
  - https://golang.org/ref/spec#Operators
- 演算子
  - 算術演算
  - 代入演算
  - ビット演算
  - 論理演算
  - 比較演算
  - アドレス演算
    - `&`：変数のポインタ（アドレス）を取得する演算子
      - e.g. 変数のポインタを取得 `&a`
    - `*`：ポインタ（アドレス）が指す値を取得する演算子
      - e.g. 変数のポインタから値を取得 `*(&a)`
  - チャネル演算
    - goroutine を使用するときに使用する演算子。チャネルへの送受信を行う演算子。
      - e.g. `ch <- 100`、`<- ch`

### 制御構文

- if、if-else
  - Go はコンパイル時に後ろに改行があると、自動でセミコロンを付与する
    - ※ 改行の前が `{` などの文字だと差し込まない
  - if 代入文と条件文を組み合わせて書く書き方は覚えておく
- for
  - while 文はなく、for 文に何も条件を書かなければ無限ループになる
- break
- goto
- switch
  - 一般的な switch 文で必要な各 case ごとの `break` は必要ない
  - case に式が使える
  - case をまたぎたい場合、`fallthrough` を使う（また使う時に調べれば OK）

#### Go はコンパイル時に後ろに改行があると、自動でセミコロンを付与する

コンパイラの仕様を一応頭に入れておく。コンパイルエラーになる、ならない書き方を紹介。

```go
// コンパイルエラーにならない
// () はいらない
if a == 0 {

}

// コンパイルエラーになる
// コンパイル時に "if a == 0" の後ろにセミコロンが入ってしまい、コンパイルエラーになる。
if a == 0
{

}

// コンパイルエラーになる
// () はつけない
if (a == 0) fmt.Println(a)
```

#### if 代入文と条件文を組み合わせて書く書き方は覚えておく

変数 `a` を、if 文の条件文を書く前に代入文で宣言している。この場合、変数 `a` は if、else のブロック内で使える変数となる。

```go
if a := f(); a > 0 {
    fmt.Println(a)
} else {
    fmt.Println(2 * a)
}
```

---

## 自作パッケージの import

自作パッケージ内の関数を、 `main.go` の中で上位パッケージからの相対パスで import したい場合、`go mod` コマンドで `go.mod` ファイルを作成すれば OK。

```sh
cd mymod  # mymod に main.go が置いてある想定
go mod init mymod
```

## ユニットテストの書き方

参考：https://qiita.com/tmzkysk/items/8bb37795ac223664d682

- 任意のモジュールの作成 `xxxx.go`
- `xxxx_test.go` という名前でモジュールを作成
- テストの実装
  - `testing` というパッケージのインポート
  - `TestXXX` という名前でテストメソッドを作成
  - テストコードを実装
  - パラメータと期待値の組み合わせの配列（例えば struct を要素とした配列）を用意して、ループで検証していく形が推奨されている
- テストの実行
  - カレントディレクトリ以下全てを再帰的にテスト
    - `go test -v ./...`
  - 特定のパッケージをテスト
    - `go test -v ./mypkg`
    - 相対パスを付けずに `go test -v mypkg` だと認識されず、エラーになる
  - 特定のメソッドのみテスト
    - `go test -v -run TestXXX ./...`
    - 特定のパッケージのテストと組み合わせられる
  - テスト実行前後に処理を入れる（setup、teardown の話）
    - 以下のように `TestMain` メソッドを実装する
  - モックを使ったテスト
    - また後で勉強する：https://qiita.com/tmzkysk/items/8bb37795ac223664d682#%E3%83%86%E3%82%B9%E3%83%88%E3%81%A7%E3%83%A2%E3%83%83%E3%82%AF%E3%82%92%E4%BD%BF%E3%81%86%E3%81%AB%E3%81%AF

```go
package calc

import (
    "fmt"
    "os"
    "testing"
)

func TestMain(m *testing.M) {
    fmt.Println("before test")
    code := m.Run()
    fmt.Println("after test")
    os.Exit(code)
}

func TestAdd(t *testing.T) {
    // 以下省略
}
```
