# メモ：プログラミング言語 Go 完全入門 <!-- omit in toc -->

スライドの写経、Go に関することなどのメモ書き

- [1. Go に触れる](#1-go-に触れる)
  - [Go とは](#go-とは)
  - [Go が開発された背景](#go-が開発された背景)
  - [Go の特徴：概要](#go-の特徴概要)
    - [強力でシンプルな言語設計と文法](#強力でシンプルな言語設計と文法)
    - [並行プログラミング](#並行プログラミング)
    - [豊富な標準ライブラリ](#豊富な標準ライブラリ)
    - [周辺ツールの充実](#周辺ツールの充実)
    - [シングルバイナリ・クロスコンパイル](#シングルバイナリクロスコンパイル)
  - [Go を学ぶ理由](#go-を学ぶ理由)
  - [コンパイルと実行](#コンパイルと実行)
  - [コーディングに必要なツール](#コーディングに必要なツール)
    - [コードの書式を揃える](#コードの書式を揃える)
    - [静的解析ツール](#静的解析ツール)
    - [PR レビューで静的解析ツールを使用](#pr-レビューで静的解析ツールを使用)
    - [デバッグ](#デバッグ)
- [小休止](#小休止)
- [2. 基本構文](#2-基本構文)
  - [変数](#変数)
    - [変数とは](#変数とは)
    - [変数と型](#変数と型)
    - [静的型付けの利点と Go の強い型付け](#静的型付けの利点と-go-の強い型付け)
  - [定数](#定数)
    - [定数とは](#定数とは)
    - [定数式](#定数式)
    - [右辺の省略](#右辺の省略)
    - [iota](#iota)
    - [疑問点](#疑問点)
  - [演算子](#演算子)
    - [Go の演算子](#go-の演算子)
  - [制御構文](#制御構文)
    - [Go はコンパイル時に後ろに改行があると、自動でセミコロンを付与する](#go-はコンパイル時に後ろに改行があると自動でセミコロンを付与する)
    - [if 代入文と条件文を組み合わせて書く書き方は覚えておく](#if-代入文と条件文を組み合わせて書く書き方は覚えておく)
- [3. 関数と型](#3-関数と型)
  - [3.1. 型](#31-型)
    - [コンポジット型](#コンポジット型)
      - [コンポジット型のゼロ値](#コンポジット型のゼロ値)
      - [コンポジット型：構造体](#コンポジット型構造体)
      - [コンポジット型：配列](#コンポジット型配列)
      - [補足：コンポジットリテラル](#補足コンポジットリテラル)
      - [コンポジット型：スライス](#コンポジット型スライス)
        - [スライスの作成](#スライスの作成)
        - [append の挙動](#append-の挙動)
      - [コンポジット型：マップ](#コンポジット型マップ)
  - [3.2. 関数](#32-関数)
  - [3.3. メソッド](#33-メソッド)
- [4. パッケージ](#4-パッケージ)
- [5. コマンドラインツール](#5-コマンドラインツール)
- [6. 抽象化](#6-抽象化)
- [7. エラー処理](#7-エラー処理)
- [8. テストとテスタビリティ](#8-テストとテスタビリティ)
- [9. ゴールーチンとチャネル](#9-ゴールーチンとチャネル)
- [10. HTTP サーバとクライアント](#10-http-サーバとクライアント)
- [11. データベース](#11-データベース)
- [12. テキスト処理](#12-テキスト処理)
- [13. リフレクション](#13-リフレクション)
- [13. 静的解析とコード生成](#13-静的解析とコード生成)
- [14. ジェネリクス（型パラメタ）](#14-ジェネリクス型パラメタ)
- [15. パフォーマンスチューニング](#15-パフォーマンスチューニング)
- [その他のメモ](#その他のメモ)
  - [自作パッケージの import](#自作パッケージの-import)
  - [ユニットテストの書き方](#ユニットテストの書き方)
- [Q&A](#qa)

## 1. Go に触れる

### Go とは

- Google が開発したプログラミング言語
- 特徴
  - 強力でシンプルな言語設計と文法
  - 並行プログラミング
  - 豊富な標準ライブラリ群
  - 周辺ツールの充実
  - シングルバイナリ・クロスコンパイル（OS、アーキテクチャを指定してコンパイルできる）

### Go が開発された背景

- **Google 内の課題を解決するために開発された**
  - 開発速度の低下
    - 超巨大なコードベース
    - 複雑な依存関係
  - マルチコア時代のシステム言語
    - 並行処理とガベージコレクタを同時に採用
  - 軽量プログラミング言語（LL、Light weight Language）の盛り上がり
    - 静的型付け言語だとコンパイル時にエラーが発見できる
    - 動的型付け言語だと書きやすい
    - 静的 / 動的型付け言語のいいとこどりをした書きやすい静的型付け言語が Go
  - 静的解析がしやすい
    - 言語設計レベルで静的解析しやすい言語を目指した

### Go の特徴：概要

- 強力でシンプルな言語設計と文法
- 並行プログラミング
- 豊富な標準ライブラリ群
- 周辺ツールの充実
- シングルバイナリ・クロスコンパイル（OS、アーキテクチャを指定してコンパイルできる）

#### 強力でシンプルな言語設計と文法

- 強力でシンプルな言語設計と文法
  - スクリプト言語の書きやすさ
    - 冗長な記述は必要ない
  - 型のある言語の厳密さ
    - 曖昧な記述ができない
  - 考えられたシンプルさ
    - 機能を増やすことで言語を拡張していくことはしない
    - 例えば、他の言語の良さそうな機能を Go にどんどん取り入れていくという文化ではない。できる限り言語設計はシンプルに保つ。

Go に入って Go に従え = 言語の思想を理解するのが大事

#### 並行プログラミング

- ゴールーチン
  - **軽量なスレッド**に近いもの（スレッドとは何が違うの？）
  - `go` キーワードを付けて関数呼び出し

```go
// 関数 f を別のゴールーチンで呼び出す
go f()
```

- チャネル
  - ゴールーチン間のデータのやり取り（スレッド間のデータのやり取りと同じ要領）
  - 安全にデータをやり取りできる

#### 豊富な標準ライブラリ

- 標準ライブラリ一覧
  - https://pkg.go.dev/std

| 標準ライブラリ名  | 内容、機能             |
| ----------------- | ---------------------- |
| fmt               | 書式、出力に関する処理 |
| net/http          | HTTP サーバなど        |
| archive, compress | zip や gzip など       |
| encoding          | JSON、XML、CSV など    |
| html/template     | HTML テンプレート      |
| os, path/filepath | ファイル操作など       |

#### 周辺ツールの充実

- `go tool` として標準 / 準標準で提供
- サードパーティ製のツールも充実
- IDE によらない独立したツールとして提供

| コマンド             | 内容、機能                            |
| -------------------- | ------------------------------------- |
| `go build`           | ビルドを行うコマンド                  |
| `go test`            | `xxxx_test.go`                        |
| `go doc`, `godoc`    | ドキュメント生成                      |
| `gofmt`, `goimports` | コードフォーマッタ                    |
| `go vet`             | コードチェッカー                      |
| `gopls`              | Language Server Protocol（LSP）の実装 |

#### シングルバイナリ・クロスコンパイル

- シングルバイナリになる
  - コンパイルするとデフォルトで単一の実行可能ファイルが生成される（C / C++ などと同じ）
  - 動作環境を特別に用意しなくてもよい（バイナリなので、インタプリタを必要とする言語と異なり、動作させる際に言語処理系が必要ない）
- クロスコンパイルできる
  - 開発環境とは違う OS やアーキテクチャ（CPU）向けのバイナリが作れる
  - 環境変数の `GOOS`（OS を指定）と `GOARCH`（アーキテクチャを指定）を指定する

```sh
# Windows(32 ビット)向けにコンパイル
$ GOOS=windows GOARCH=386 go build

# Linux(64 ビット)向けにコンパイル
$ GOOS=linux GOARCH=amd64 go build
```

`go build` は Go のソースコードをビルドするコマンド

### Go を学ぶ理由

- 多くのプロダクトで採用
  - https://github.com/golang/go/wiki/GoUsers#japan
- チーム開発に向いている
  - 静的型付け
  - 文法がシンプル
- パフォーマンスが良い
  - ゴールーチンとチャネル
  - バイナリになる（インタプリタを必要とする言語と異なり、動作させる際に言語処理系が必要ない）

### コンパイルと実行

- `go build` コマンド
  - コンパイルして実行可能ファイル（バイナリファイル）を生成

```sh
go build main.go
go build .
go build pkg_name
```

- `go run` コマンド
  - コンパイルから実行まで行う

```sh
go run main.go
go run .
go run pkg_name
```

### コーディングに必要なツール

#### コードの書式を揃える

- gofmt
  - 読み方:ごーふむと
  - 標準のフォーマッタ
  - **絶対に使う**
  - `-s` オプションで冗長な書き方をシンプルにできる
- goimports
  - `import` 文を追加 / 削除してくれる
  - 未使用パッケージ `import` コンパイルエラーなのでで必須
  - フォーマットもかける
  - `-s` オプションがない

#### 静的解析ツール

| ツール名      | 機能                                                               |
| ------------- | ------------------------------------------------------------------ |
| go vet        | バグと言えるレベルの誤りを検出（これで検出されるのはだいたいバグ） |
| golint        | （非推奨）Go らしくないコードを検出                                |
| errcheck      | エラー処理のミスを検出                                             |
| staticcheck   | サードパーティ製の静的解析ツール                                   |
| GolangCI-Lint | サードパーティ製の Linter Runner                                   |
| gosec         | セキュリティチェック                                               |

#### PR レビューで静的解析ツールを使用

- reviewdog
  - リポジトリ：https://github.com/reviewdog/reviewdog
  - レビュー時に自動で静的解析ツールを実行する
  - 機械的にチェックできることは機械にやらせる
  - 人間だと忘れたり、心苦しかったりしてチェックが漏れる
  - 設定ファイルを書けば reviewdog が勝手に PR にコメントをくれる

#### デバッグ

- GDB
  - リポジトリ：https://golang.org/doc/gdb
  - 有名な古き良きデバッガ
  - Go 自体にカスタマイズされてるわけではない。（Go 開発では使わない？）
- Delve
  - リポジトリ：https://github.com/derekparker/delve
  - Go 専用のデバッガでよく使われる
  - ゴールーチンやチャネルにも対応
- panic デバッグ
  - `panic` 関数を使ってデバッグ
  - スタックトレースが出るので便利
- print デバッグ

## 小休止

Go を Homebrew を用いてインストールし、VSCode の Go 拡張を入れてコードを書き始めようとしたら、Go 拡張に必要なツールが無くて怒られた。

以下、必要なツールのインストールコマンド。

```sh
# "gopls"（Language Server Protocol）
go get -v golang.org/x/tools/gopls

# "goimports"
go get -v golang.org/x/tools/cmd/goimports

# "go-outline"
go get -v github.com/ramya-rao-a/go-outline

# "gopkgs"
go get -v github.com/uudashr/gopkgs/v2/cmd/gopkgs
```

## 2. 基本構文

1. 変数
2. 定数
3. 演算子
4. 制御構文

### 変数

#### 変数とは

- 変数 variable
  - 識別子、それに関連付けられたメモリアドレス、型から構成されるもので、プログラミング言語の仕様。プログラム実行中に一時的に値を保存（状態を保存）しておくための仕組みとして利用される。例えば、一時的な計算結果の保持などに利用される。
  - メモリ上にある値なので、マシンが止まると消える（揮発性）
  - プログラムの実行が終わると消える
  - 変数の内容を結果として残したい場合、ファイルなど外部記憶装置上で管理される領域や出力装置（プリンタなど）経由で出力する必要がある

#### 変数と型

- 型 type
  - どういう種類の値かを表すもの
  - 整数、浮動小数点数、真偽値、文字列 など
  - 自分で作ることも可能（ユーザ定義型）
  - 変数の型：どういう種類の値が入るのかを表したもの
- 型の扱いによるプログラミング言語の分類
  - 動的型付け言語 dynamically typed language
    - **プログラム実行時に「値の型」を検証する**（型が無いわけではないよ！）
    - 変数に型がなく、なんでも代入できる
  - 静的型付け言語 statically typed language
    - **コンパイル時に「変数の型」を検証する**
    - 変数に型がある、型が違うと代入できない

#### 静的型付けの利点と Go の強い型付け

型の一番の恩恵は、「プログラムの実装中には見つけづらい型の不一致によるエラーを、実行前にコンパイラにより検出でき、それにより生産性が上がる」ことである。動的型付け言語の場合、型の不一致によるエラーには実装中に気づかず、実行してから実行時エラーとして気付くということがしばしば見られる。

- **実行前に型の不一致を検出できる**
  - コンパイルが通れば型の不一致が起きない
  - 型の不一致によるバグは見つけづらいので、これをプログラム実行前に行えるのは効率的
- **曖昧なものはエラーになる**
  - 暗黙の型変換がない
  - 1 + "2" => "12"（JavaScript）
  - 浮動小数点数と整数の演算など見つけづらいバグが起きにくい
- **型推論がある**
  - 明示的に型を書く必要がない場合が多い

### 定数

- https://blog.golang.org/constants

#### 定数とは

- 定数 constant
  - 値の変わらないもの
  - コンパイル時から値が変わらないもの
  - リテラルで記述されることが多い

#### 定数式

- 定数式
  - 定数のみからなる演算式。コンパイル時に計算される。

例えば以下のようなコード。

```go
100 + 200
1 << 2
"Hello, " + "世界"
!(10 == 20)
```

#### 右辺の省略

- 右辺の省略

```go
func main()  {
    const (
        a = 1 + 2  // 3（以下、全て 3 になる）
        b          // 3
        c          // 3
    )

    fmt.Println(a, b, c)  // 全て 3 が出力される
}
```

#### iota

- iota
  - 連続した定数を作るための仕組み
  - グループ化された名前付き定数の定義で使われる
  - 0 から始まり 1 ずつ加算される値として扱われる

```go
func main()  {
    const (
        a = iota  // + 0
        b         // + 1
    )
    const (
        c = 1 << iota  // 1 << 0 = 1 (0001 --- 0 桁左シフト --> 0001)
        d              // 1 << 1 = 2 (0001 --- 1 桁左シフト --> 0010)
        e              // 1 << 2 = 4 (0001 --- 2 桁左シフト --> 0100)
    )

    fmt.Println(a, b, c, d, e)  // 0, 1, 1, 2, 4
}
```

#### 疑問点

- なぜ「型を持たない定数」という言語仕様を意図して作ったのか？
  - どういうメリットが有るのか？定数にも確実に型付けが行われるような仕様にした方が良いのではないか？

### 演算子

#### Go の演算子

- 演算子一覧
  - https://golang.org/ref/spec#Operators
- 演算子
  - 算術演算
  - 代入演算
  - ビット演算
  - 論理演算
  - 比較演算
  - アドレス演算
    - `&`：変数のポインタ（アドレス）を取得する演算子
      - e.g. 変数のポインタを取得 `&a`
    - `*`：ポインタ（アドレス）が指す値を取得する演算子
      - e.g. 変数のポインタから値を取得 `*(&a)`
  - チャネル演算
    - goroutine を使用するときに使用する演算子。チャネルへの送受信を行う演算子。
      - e.g. `ch <- 100`、`<- ch`

### 制御構文

- if、if-else
  - Go はコンパイル時に後ろに改行があると、自動でセミコロンを付与する
    - ※ 改行の前が `{` などの文字だと差し込まない
  - if 代入文と条件文を組み合わせて書く書き方は覚えておく
- for
  - `for 初期値; 継続条件; 更新文`
  - while 文はない
  - 継続条件のみを書くと while 文っぽくなる
  - for 文に何も条件を書かなければ無限ループになる
- break
- goto
- switch
  - 一般的な switch 文で必要な各 case ごとの `break` は必要ない
  - case に式が使える
  - case をまたぎたい場合、`fallthrough` を使う（また使う時に調べれば OK）

#### Go はコンパイル時に後ろに改行があると、自動でセミコロンを付与する

コンパイラの仕様を一応頭に入れておく。コンパイルエラーになる、ならない書き方を紹介。

```go
// コンパイルエラーにならない
// () はいらない
if a == 0 {

}

// コンパイルエラーになる
// コンパイル時に "if a == 0" の後ろにセミコロンが入ってしまい、コンパイルエラーになる。
if a == 0
{

}

// コンパイルエラーになる
// () はつけない
if (a == 0) fmt.Println(a)
```

#### if 代入文と条件文を組み合わせて書く書き方は覚えておく

変数 `a` を、if 文の条件文を書く前に代入文で宣言している。この場合、変数 `a` は if、else のブロック内で使える変数となる。

```go
if a := f(); a > 0 {
    fmt.Println(a)
} else {
    fmt.Println(2 * a)
}
```

## 3. 関数と型

スライド：[3. 関数と型](https://docs.google.com/presentation/d/1DtWB-8FcnNb9asxSpIaOLYbAEc9OjBAwMLNxKnPA8pc/edit#slide=id.g4cbe4d134e_0_0)

3.1. 型
3.2. 関数
3.3. メソッド

### 3.1. 型

- 型 type
  - どういう種類の値かを表すもの
  - 整数、浮動小数点数、真偽値、文字列 など
  - 自分で作ることも可能（ユーザ定義型）
  - 変数の型：どういう種類の値が入るのかを表したもの
- 型の扱いによるプログラミング言語の分類
  - 動的型付け言語 dynamically typed language
    - **プログラム実行時に値の型を検証する**（型が無いわけではないよ！）
    - 変数に型がなく、なんでも代入できる
  - 静的型付け言語 statically typed language
    - **コンパイル時に変数の型を検証する**
    - 変数に型がある、型が違うと代入できない
- 実装上の型の分類
  - 組み込み型
    - 言語に元から組み込まれている型。特に必要なパッケージの import なくコードを書くときに使える。
  - コンポジット型
  - ユーザ定義型
- 型のキャスト
  - 特定の値の型を別の型に変換すること
  - `T(v)`

```go
package main

func main() {
  var f float64 = 10
  var n int = int(f)
  println(n)
}
```

#### コンポジット型

- コンポジット型
  - 複数のデータ型が集まって 1 つのデータ型になっている。集まり方によって種類がある。
  - なぜコンポジット型が必要か？
    - 単一のデータを保持する型だけだと、大量のデータを扱う場合に非常に不便になる。

| 型の種類     | 説明                                     |
| ------------ | ---------------------------------------- |
| **構造体**   | 型の異なるデータ型の変数を集めたデータ型 |
| **配列**     | 同じ型のデータを集めて "並べた" データ型 |
| **スライス** | 配列の一部を切り出したデータ型           |
| **マップ**   | キーと値をマッピングさせたデータ型       |

- 型リテラル
  - 型の具体的な定義を書き下した型の表現方法
  - コンポジット型などを表現するために使う
  - 用途
    - 変数定義やユーザ定義型などで使用する
  - 補足
    - **リテラル = プログラム中で識別子（名前）が付与されてないもの**

##### コンポジット型のゼロ値

- Go における「ゼロ値」
  - Go の変数は定義時に必ず何かの値で初期化される。もし変数初期化時に特定の値を変数の初期値と指定しない場合、デフォルトの値で初期化される。このときの値を「ゼロ値」という。
  - コンポジット型のゼロ値はデータの表現方法によって異なる
    - 構造体や配列は要素（フィールド）が全てゼロ値の値で初期化される
    - スライスやマップは特殊で、初期化のために材料が必要になる。`make` 関数などで初期化が必要なためゼロ値は `nil` となる。

| 型の種類     | ゼロ値                           |
| ------------ | -------------------------------- |
| **構造体**   | フィールドのそれぞれの型のゼロ値 |
| **配列**     | 配列の要素の型のゼロ値           |
| **スライス** | `nil`                            |
| **マップ**   | `nil`                            |

##### コンポジット型：構造体

- 構造体
  - 型の異なるデータ型の変数を集めたデータ構造
    - 各変数は「フィールド」と呼ばれる
    - 下の例では、「構造体 `p` はフィールド `name` と `age` を持つ」という
    - フィールドの型は異なってもよい（同じ型も可）
    - フィールドの型には組み込み型以外も使える
      - コンポジット型やユーザ定義型も構造体のフィールドとして定義可能
      - 「構造体の変数をフィールドに持つ構造体」が可能。もっと入れ子になっても OK。
- 構造体を使う
  - 構造体の型リテラル
  - 構造体リテラル

##### コンポジット型：配列

- 配列
  - 同じ型のデータを集めて並べたデータ構造
    - 要素の型は全て同じ
    - Go の配列は**固定長配列**
    - 要素数が違えば別の型
      - つまり、`[5]int` と `[4]int` は配列だけど異なる型として認識される。配列の長さも型の情報に含まれる。
    - 要素数は変更できない
    - 型は型リテラルで記述することが多い
  - Go ではそんなに配列を使わない。スライスの方がよく使われる。
- 配列を使う
  - 配列の型リテラル
  - 配列リテラル

##### 補足：コンポジットリテラル

Go の文法上では、構造体リテラルと配列リテラルは同じ。「コンポジットリテラル」として言語仕様に定義されている。構造体リテラルでは、（実装上はあまりやらないけど）配列リテラルと同じくフィールド名を省略できる。

一見違うことをしているように見えているものが、文法として捉えると全く同じことをしているということがあるので、プログラミング言語を学ぶときはそういった点にも注意して学ぶと良い。**文法を覚えると、覚えることが少なくて良くなる。「文法上正しいからこれは書けるよね」という考え方になって、どのような書き方が OK か NG かが瞬時に分かるようになる。**

- コンポジットリテラル
  - [Composite literals | Go Documentation](https://golang.org/ref/spec#Composite_literals)

##### コンポジット型：スライス

- スライスの説明
  - [スライド](https://docs.google.com/presentation/d/1DtWB-8FcnNb9asxSpIaOLYbAEc9OjBAwMLNxKnPA8pc/edit#slide=id.g4cbe4d134e_0_191)
  - 動画
    - 29:48 ~ 1:10:12

![Image: Slice of Go](img/chap03_Go_slice.png)

（[「プログラミング言語 Go 完全入門」のスライド](https://docs.google.com/presentation/d/1DtWB-8FcnNb9asxSpIaOLYbAEc9OjBAwMLNxKnPA8pc/edit#slide=id.g4cbe4d134e_0_191)より引用）

- スライス
  - [spec: Slice types](https://golang.org/ref/spec#Slice_types)
  - 説明
    - 配列の一部を切り出したデータ構造
  - 特徴
    - 要素の型は全て同じ（配列の一部の切り出しなので当然）
    - 要素数は型情報に含まない
    - **背後に配列が存在する**
    - 初期値はゼロ値ではなく `nil`
  - スライスの型情報
    - ポインタ：スライスの最初の要素へのポインタ
    - len：スライスの長さ
    - cap：スライスの最初の要素から、背後にある配列の末尾までの要素数。要は「スライスの容量」（背後の配列が確保しているメモリ幅）

```go
ns :=[...]int{10, 20, 30, 40, 50}
s := ns[1:3] // s := []int{20, 30}
```

- （自分的な）スライスのポイント
  - 背後にある配列を意識する
  - コピーコストを意識する
    - ただし、早すぎる最適化は NG。パフォーマンスがこっちの方が良いということが自明の場合のみ。

###### スライスの作成

スライスの作成には主に以下の 3 つの方法がある。

1. 配列から作成
2. 直接スライスの宣言
3. `make` 関数を使って初期化
4. `new` 関数を使って初期化

```go
// 1
arr := [...]int{10, 20, 30, 40, 50}
sl := arr[0:3]
// start のインデックスが 0 の場合、省略可能
// sl := arr[:3]

// 2
sl := []int{10, 20, 30}

// 3
sl := make([]T, length, capacity)
sl := make([]int, 5, 5)

// 4
sl := new([5]int)[0:5]
```

###### append の挙動

- 容量が足りる場合
  - 新しい要素をコピーする
  - `len` を更新する
- 容量が足りない場合
  - 元の "およそ 2 倍" の容量の配列を確保し直す
  - 配列へのポインタを貼り直す
  - 元の配列から要素をコピーする
  - 新しい要素をコピーする
  - `len`、`cap` を更新する

![Image: append の挙動 - 1](img/chap03_append.png)

（[引用元](https://docs.google.com/presentation/d/1DtWB-8FcnNb9asxSpIaOLYbAEc9OjBAwMLNxKnPA8pc/edit#slide=id.g4cbe4d134e_0_837)）

![Image: append の挙動 - 2](img/chap03_append2.png)

（[引用元](https://docs.google.com/presentation/d/1DtWB-8FcnNb9asxSpIaOLYbAEc9OjBAwMLNxKnPA8pc/edit#slide=id.g7dc1d6af71_0_121)）

##### コンポジット型：マップ

- 初期化時の値（ゼロ値）は nil
  - `make` で作るものはだいたいゼロ値は `nil`
    - マップ、スライス、チャネル
- key の値は `==` で比較可能なもの
  - 比較可能：int、string、ポインタ、配列、構造体、...
  - 比較不可能：スライス、スライスを要素に持つ配列や構造体
    - スライスは `nil` としか比較できない。スライスが等しいか調べたいなら for 文を使うしか無い。
- ゼロ値が便利

### 3.2. 関数

### 3.3. メソッド

## 4. パッケージ

todo

## 5. コマンドラインツール

todo

## 6. 抽象化

todo

## 7. エラー処理

todo

## 8. テストとテスタビリティ

todo

## 9. ゴールーチンとチャネル

todo

## 10. HTTP サーバとクライアント

todo

## 11. データベース

todo

## 12. テキスト処理

todo

## 13. リフレクション

todo

## 13. 静的解析とコード生成

todo

## 14. ジェネリクス（型パラメタ）

todo

## 15. パフォーマンスチューニング

todo

---

## その他のメモ

### 自作パッケージの import

自作パッケージ内の関数を、 `main.go` の中で上位パッケージからの相対パスで import したい場合、`go mod` コマンドで `go.mod` ファイルを作成すれば OK。

```sh
cd mymod  # mymod に main.go が置いてある想定
go mod init mymod
```

### ユニットテストの書き方

参考：https://qiita.com/tmzkysk/items/8bb37795ac223664d682

- 任意のモジュールの作成 `xxxx.go`
- `xxxx_test.go` という名前でモジュールを作成
- テストの実装
  - `testing` というパッケージのインポート
  - `TestXXX` という名前でテストメソッドを作成
  - テストコードを実装
  - パラメータと期待値の組み合わせの配列（例えば struct を要素とした配列）を用意して、ループで検証していく形が推奨されている
- テストの実行
  - カレントディレクトリ以下全てを再帰的にテスト
    - `go test -v ./...`
  - 特定のパッケージをテスト
    - `go test -v ./mypkg`
    - 相対パスを付けずに `go test -v mypkg` だと認識されず、エラーになる
  - 特定のメソッドのみテスト
    - `go test -v -run TestXXX ./...`
    - 特定のパッケージのテストと組み合わせられる
  - テスト実行前後に処理を入れる（setup、teardown の話）
    - 以下のように `TestMain` メソッドを実装する
  - モックを使ったテスト
    - また後で勉強する：https://qiita.com/tmzkysk/items/8bb37795ac223664d682#%E3%83%86%E3%82%B9%E3%83%88%E3%81%A7%E3%83%A2%E3%83%83%E3%82%AF%E3%82%92%E4%BD%BF%E3%81%86%E3%81%AB%E3%81%AF

```go
package calc

import (
    "fmt"
    "os"
    "testing"
)

func TestMain(m *testing.M) {
    fmt.Println("before test")
    code := m.Run()
    fmt.Println("after test")
    os.Exit(code)
}

func TestAdd(t *testing.T) {
    // 以下省略
}
```

## Q&A

- 整数型の `rune` が謎
